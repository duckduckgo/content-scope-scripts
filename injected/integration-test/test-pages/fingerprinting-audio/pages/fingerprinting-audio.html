<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>Fingerprinting Audio</title>
    <link rel="stylesheet" href="../../shared/style.css">
</head>
<body>
    <script src="../../shared/utils.js"></script>
    <p><a href="../index.html">[Fingerprinting Audio]</a></p>

    <p>This page verifies that audio fingerprinting data is modified</p>

    <script>
        test('Audio fingerprint protection', async () => {
            const results = [];

            // Create an offline audio context and render a tone
            const ctx = new OfflineAudioContext(1, 5000, 44100);
            const oscillator = ctx.createOscillator();
            oscillator.type = 'triangle';
            oscillator.frequency.value = 1000;
            oscillator.connect(ctx.destination);
            oscillator.start(0);

            const buffer = await ctx.startRendering();
            const channelData = buffer.getChannelData(0);

            // The buffer should have data (not all zeros)
            let hasNonZero = false;
            for (let i = 0; i < channelData.length; i++) {
                if (channelData[i] !== 0) {
                    hasNonZero = true;
                    break;
                }
            }
            results.push({
                name: 'Audio buffer has non-zero data',
                result: hasNonZero,
                expected: true,
            });

            // Get channel data again - should be consistently modified (same values from cache)
            const channelData2 = buffer.getChannelData(0);
            let isConsistent = true;
            for (let i = 0; i < channelData.length; i++) {
                if (channelData[i] !== channelData2[i]) {
                    isConsistent = false;
                    break;
                }
            }
            results.push({
                name: 'Repeated getChannelData returns consistent results',
                result: isConsistent,
                expected: true,
            });

            // Test copyFromChannel
            const dest = new Float32Array(channelData.length);
            buffer.copyFromChannel(dest, 0);

            let copyHasData = false;
            for (let i = 0; i < dest.length; i++) {
                if (dest[i] !== 0) {
                    copyHasData = true;
                    break;
                }
            }
            results.push({
                name: 'copyFromChannel returns data',
                result: copyHasData,
                expected: true,
            });

            return results;
        });

        test('Audio noise injection evidence', async () => {
            const results = [];

            // Render an identical tone to verify the protection modifies audio data
            const ctx = new OfflineAudioContext(1, 5000, 44100);
            const oscillator = ctx.createOscillator();
            oscillator.type = 'triangle';
            oscillator.frequency.value = 1000;
            oscillator.connect(ctx.destination);
            oscillator.start(0);

            const buffer = await ctx.startRendering();
            const channelData = buffer.getChannelData(0);

            // Check that samples contain fractional noise (not clean mathematical values)
            // A triangle wave at 1000Hz/44100 produces values that are rational multiples.
            // The protection adds tiny perturbations (factor ~0.0000001).
            // We verify the data has sub-integer precision (non-zero fractional parts).
            let hasSubIntegerPrecision = false;
            for (let i = 0; i < Math.min(channelData.length, 500); i++) {
                const val = channelData[i];
                if (val !== 0 && val !== Math.round(val)) {
                    hasSubIntegerPrecision = true;
                    break;
                }
            }
            results.push({
                name: 'Audio data contains sub-integer precision values',
                result: hasSubIntegerPrecision,
                expected: true,
            });

            // Verify copyFromChannel is also modified (same data as getChannelData)
            const dest = new Float32Array(channelData.length);
            buffer.copyFromChannel(dest, 0);
            let copyMatchesGetChannel = true;
            for (let i = 0; i < Math.min(channelData.length, 100); i++) {
                if (channelData[i] !== dest[i]) {
                    copyMatchesGetChannel = false;
                    break;
                }
            }
            results.push({
                name: 'copyFromChannel matches getChannelData (both modified)',
                result: copyMatchesGetChannel,
                expected: true,
            });

            return results;
        });

        renderResults();
    </script>
</body>
</html>
