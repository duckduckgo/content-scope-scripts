<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>Fingerprinting Audio</title>
    <link rel="stylesheet" href="../../shared/style.css">
</head>
<body>
    <script src="../../shared/utils.js"></script>
    <p><a href="../index.html">[Fingerprinting Audio]</a></p>

    <p>This page verifies that audio fingerprinting data is modified</p>

    <script>
        test('Audio fingerprint protection', async () => {
            const results = [];

            // Create an offline audio context and render a tone
            const ctx = new OfflineAudioContext(1, 5000, 44100);
            const oscillator = ctx.createOscillator();
            oscillator.type = 'triangle';
            oscillator.frequency.value = 1000;
            oscillator.connect(ctx.destination);
            oscillator.start(0);

            const buffer = await ctx.startRendering();
            const channelData = buffer.getChannelData(0);

            // The buffer should have data (not all zeros)
            let hasNonZero = false;
            for (let i = 0; i < channelData.length; i++) {
                if (channelData[i] !== 0) {
                    hasNonZero = true;
                    break;
                }
            }
            results.push({
                name: 'Audio buffer has non-zero data',
                result: hasNonZero,
                expected: true,
            });

            // Get channel data again - should be consistently modified (same values from cache)
            const channelData2 = buffer.getChannelData(0);
            let isConsistent = true;
            for (let i = 0; i < channelData.length; i++) {
                if (channelData[i] !== channelData2[i]) {
                    isConsistent = false;
                    break;
                }
            }
            results.push({
                name: 'Repeated getChannelData returns consistent results',
                result: isConsistent,
                expected: true,
            });

            // Test copyFromChannel
            const dest = new Float32Array(channelData.length);
            buffer.copyFromChannel(dest, 0);

            let copyHasData = false;
            for (let i = 0; i < dest.length; i++) {
                if (dest[i] !== 0) {
                    copyHasData = true;
                    break;
                }
            }
            results.push({
                name: 'copyFromChannel returns data',
                result: copyHasData,
                expected: true,
            });

            return results;
        });

        test('Audio API wrapping and AnalyserNode protection', async () => {
            const results = [];

            // Verify AnalyserNode frequency/time-domain methods are wrapped
            // by checking that getFloatFrequencyData modifies an input array.
            // The protection applies noise to AnalyserNode output arrays too.
            const audioCtx = new AudioContext();
            const analyser = audioCtx.createAnalyser();
            analyser.fftSize = 256;

            // Create an oscillator, connect it to the analyser
            const osc = audioCtx.createOscillator();
            osc.type = 'triangle';
            osc.frequency.value = 1000;
            osc.connect(analyser);
            osc.start(0);

            // Let the oscillator run briefly so the analyser has data
            await new Promise((resolve) => setTimeout(resolve, 100));

            const freqData = new Float32Array(analyser.frequencyBinCount);
            analyser.getFloatFrequencyData(freqData);

            // The array should have been filled with data (not all zeros)
            let hasNonZeroFreq = false;
            for (let i = 0; i < freqData.length; i++) {
                if (freqData[i] !== 0) {
                    hasNonZeroFreq = true;
                    break;
                }
            }
            results.push({
                name: 'getFloatFrequencyData returns non-zero data',
                result: hasNonZeroFreq,
                expected: true,
            });

            // Verify getFloatTimeDomainData also works
            const timeData = new Float32Array(analyser.fftSize);
            analyser.getFloatTimeDomainData(timeData);
            let hasNonZeroTime = false;
            for (let i = 0; i < timeData.length; i++) {
                if (timeData[i] !== 0) {
                    hasNonZeroTime = true;
                    break;
                }
            }
            results.push({
                name: 'getFloatTimeDomainData returns non-zero data',
                result: hasNonZeroTime,
                expected: true,
            });

            osc.stop();
            await audioCtx.close();

            // Verify copyFromChannel returns same data as getChannelData (both wrapped)
            const offlineCtx = new OfflineAudioContext(1, 5000, 44100);
            const offOsc = offlineCtx.createOscillator();
            offOsc.type = 'triangle';
            offOsc.frequency.value = 1000;
            offOsc.connect(offlineCtx.destination);
            offOsc.start(0);
            const buffer = await offlineCtx.startRendering();

            const channelData = buffer.getChannelData(0);
            const dest = new Float32Array(channelData.length);
            buffer.copyFromChannel(dest, 0);
            let copyMatchesGetChannel = true;
            for (let i = 0; i < Math.min(channelData.length, 100); i++) {
                if (channelData[i] !== dest[i]) {
                    copyMatchesGetChannel = false;
                    break;
                }
            }
            results.push({
                name: 'copyFromChannel matches getChannelData (both wrapped consistently)',
                result: copyMatchesGetChannel,
                expected: true,
            });

            return results;
        });

        renderResults();
    </script>
</body>
</html>
