<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Webcompat shims</title>
  <link rel="stylesheet" href="../../shared/style.css">
</head>
<body>
    <script src="../../shared/utils.js"></script>
    <p><a href="../index.html">[Webcompat shims]</a></p>

    <p>This page verifies that shims created with shim APIs have correct descriptors</p>

    <script>
        /**
         * assert that two descriptors are similar, allowing different values
         * @param {import('../src/wrapper-utils').StrictPropertyDescriptor} origDesc
         * @param {import('../src/wrapper-utils').StrictPropertyDescriptor} newDesc
         * @returns {string} - the error message if the test fails
         */
        function compareDescriptorShape (origDesc, newDesc) {
            const origKeys = Object.keys(origDesc)
            const newKeys = Object.keys(newDesc)
            // verify that both descriptors have the same keys
            if (origKeys.sort().join(',') !== newKeys.sort().join(','))
                return 'property keys do not match';

            for (const key of origKeys) {
                if (key === 'get' || key === 'set' || key === 'value') {
                    if (typeof newDesc[key] !== typeof origDesc[key])
                        return `property ${key} does not match`;
                } else {
                    if (newDesc[key] !== origDesc[key])
                        return `property ${key} does not match`;
                }
            }
        }

        /**
         * Use this function to test the interfaces shimmed in the web-compat feature
         * @param {string} interfaceName - the name of the interface to test. It should be available in the global scope
         * @param {import('../src/wrapper-utils').StrictPropertyDescriptor} origInterfaceDescriptor - the descriptor of the original interface
         * @returns {string} - the error message if the test fails
         */
        function testInterfaceShimCorrectness (interfaceName, origInterfaceDescriptor) {
            if (!interfaceName) {
                return 'Nothing to test.';
            }

            if (!globalThis[interfaceName])
                return 'native class is not found after shimming';
            if (globalThis[interfaceName][globalThis.ddgShimMark] !== true)
                return 'class should be marked as shimmed';

            const newInterfaceDescriptor = Object.getOwnPropertyDescriptor(globalThis, interfaceName)

            return compareDescriptorShape(origInterfaceDescriptor, newInterfaceDescriptor)
        }

        /**
         * Use this function to test the global properties shimmed in the web-compat feature
         * @param {any} instanceHost - object under which the global instance is defined
         * @param {string} instanceProp - the name of the instance property
         * @param {import('../src/wrapper-utils').StrictPropertyDescriptor} origInstanceDescriptor - the descriptor of the original instance property
         * @returns {string} - the error message if the test fails
         */
        function testInstanceShimCorrectness (instanceHost, instanceProp, origInstanceDescriptor) {
            if (!instanceHost || !instanceProp) {
                return 'Nothing to test.';
            }

            if (!instanceHost[instanceProp])
                return 'global instance is not found after shimming';

            const newInstanceDescriptor = Object.getOwnPropertyDescriptor(instanceHost, instanceProp)

            return compareDescriptorShape(origInstanceDescriptor, newInstanceDescriptor)
        }


        test('Interface shims', async () => {
            const results = [];
            results.push({
                name: 'origInterfaceDescriptors found',
                result: Boolean(globalThis.origInterfaceDescriptors),
                expected: true
            });
            results.push({
                name: 'ddgShimMark found',
                result: Boolean(globalThis.ddgShimMark),
                expected: true
            });

            for (const [interfaceName, origDescriptor] of Object.entries(globalThis.origInterfaceDescriptors)) {
                results.push({
                    name: `${interfaceName}'s descriptor is correct`,
                    result: testInterfaceShimCorrectness(interfaceName, origDescriptor),
                    expected: undefined
                });
            }

            return results;
        });

        test('Instance shims', async () => {
            const results = [];
            results.push({
                name: 'origPropDescriptors found',
                result: Boolean(globalThis.origPropDescriptors),
                expected: true
            });

            for (const [instanceHost, instanceProp, origDescriptor] of globalThis.origPropDescriptors) {
                results.push({
                    name: `${instanceHost}.${instanceProp}'s descriptor is correct`,
                    result: testInstanceShimCorrectness(instanceHost, instanceProp, origDescriptor),
                    expected: undefined
                });
            }

            return results;
        });

        test('PresentationRequest behavior', async () => {
            const results = [];

            function assertRejectsNotSupportedError(promise) {
                return promise.then(
                    () => 'resolved',
                    (e) => (e && e.name) || String(e)
                );
            }

            results.push({
                name: 'PresentationRequest exists',
                result: typeof globalThis.PresentationRequest,
                expected: 'function'
            });

            let request;
            try {
                request = new PresentationRequest('https://example.invalid/presentation');
                results.push({
                    name: 'new PresentationRequest(string) works',
                    result: true,
                    expected: true
                });
            } catch (e) {
                results.push({
                    name: 'new PresentationRequest(string) works',
                    result: (e && e.name) || String(e),
                    expected: true
                });
            }

            if (request) {
                results.push({
                    name: 'PresentationRequest.urls is an array',
                    result: Array.isArray(request.urls),
                    expected: true
                });

                results.push({
                    name: 'PresentationRequest.urls returns provided URL',
                    result: request.urls && request.urls[0],
                    expected: 'https://example.invalid/presentation'
                });

                const urls = request.urls;
                urls.push('https://example.invalid/mutation');
                results.push({
                    name: 'PresentationRequest.urls is a copy (mutation does not persist)',
                    result: request.urls.length,
                    expected: 1
                });

                results.push({
                    name: 'PresentationRequest.onconnectionavailable defaults to null',
                    result: request.onconnectionavailable,
                    expected: null
                });

                results.push({
                    name: 'PresentationRequest.start rejects NotSupportedError',
                    result: await assertRejectsNotSupportedError(request.start()),
                    expected: 'NotSupportedError'
                });

                results.push({
                    name: 'PresentationRequest.reconnect rejects NotSupportedError',
                    result: await assertRejectsNotSupportedError(request.reconnect('dummy')),
                    expected: 'NotSupportedError'
                });

                results.push({
                    name: 'PresentationRequest.getAvailability rejects NotSupportedError',
                    result: await assertRejectsNotSupportedError(request.getAvailability()),
                    expected: 'NotSupportedError'
                });

                // defaultRequest is writable in the spec and is used by feature detection.
                // @ts-expect-error - presentation is not in TS Navigator type
                navigator.presentation.defaultRequest = request;
                // @ts-expect-error - presentation is not in TS Navigator type
                results.push({
                    name: 'navigator.presentation.defaultRequest accepts PresentationRequest',
                    result: navigator.presentation.defaultRequest === request,
                    expected: true
                });
                // @ts-expect-error - presentation is not in TS Navigator type
                navigator.presentation.defaultRequest = null;
                // @ts-expect-error - presentation is not in TS Navigator type
                results.push({
                    name: 'navigator.presentation.defaultRequest accepts null',
                    result: navigator.presentation.defaultRequest,
                    expected: null
                });
            }

            return results;
        });

        // eslint-disable-next-line no-undef
        renderResults();
    </script>
</body>
</html>
